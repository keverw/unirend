import { APIServer } from './api-server';
import { staticContent } from '../built-in-plugins/static-content';
import { StaticContentCache } from './static-content-cache';
import type { StaticWebServerOptions, ServerPlugin } from '../types';
import { readJSONFile, readHTMLFile } from './fs-utils';
import { escapeHTML } from './html-utils/escape';
import type { FastifyRequest } from 'fastify';
import path from 'path';

/**
 * Default 404 Not Found HTML page
 * Proper HTML5 document structure with accessibility and mobile viewport support
 */
const DEFAULT_404_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>404 Not Found</title>
</head>
<body>
  <h1>404 Not Found</h1>
  <p>The page you requested could not be found.</p>
</body>
</html>`;

/**
 * Default 500 Internal Server Error HTML page template
 * Proper HTML5 document structure with accessibility and mobile viewport support
 * Includes error stack trace when in development mode (HTML-escaped to prevent XSS)
 */
function createDefault500HTML(isDevelopment: boolean, error?: Error): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>500 Internal Server Error</title>
</head>
<body>
  <h1>500 Internal Server Error</h1>
  <p>An error occurred while processing your request.</p>
  ${isDevelopment && error ? `<pre>${escapeHTML(error.stack || 'No stack trace available')}</pre>` : ''}
</body>
</html>`;
}

/**
 * Load an error page HTML file with fallback strategy
 * 1. Try page map entry first (e.g., singleAssetMap['/404']) - already in memory
 * 2. Try custom path if specified - filesystem read
 * 3. Try default filename in buildDir (e.g., '404.html') - filesystem read
 * 4. Return undefined if not found
 *
 * Returns both the HTML content and the resolved file path (for removing from page map)
 */
async function loadErrorPageHTML(
  customPath: string | undefined,
  pageMapPath: string | undefined,
  defaultFilename: string,
  buildDir: string,
): Promise<{ html: string; filePath: string } | undefined> {
  // Try page map first (already in memory, most efficient)
  if (pageMapPath) {
    const result = await readHTMLFile(pageMapPath);

    if (result.exists && result.content) {
      return { html: result.content, filePath: pageMapPath };
    }
  }

  // Try custom path next
  if (customPath) {
    const customFullPath = path.resolve(buildDir, customPath);
    const result = await readHTMLFile(customFullPath);

    if (result.exists && result.content) {
      return { html: result.content, filePath: customFullPath };
    }
  }

  // Fall back to default filename
  const defaultPath = path.resolve(buildDir, defaultFilename);
  const result = await readHTMLFile(defaultPath);

  if (result.exists && result.content) {
    return { html: result.content, filePath: defaultPath };
  }

  return undefined;
}

/**
 * Static Web Server for serving SSG-generated sites
 *
 * Wraps APIServer with static file serving capabilities, designed specifically
 * for serving pre-rendered static HTML pages generated by SSG.
 *
 * Features:
 * - Consumes page-map.json from SSG generation
 * - Serves clean URLs without .html extensions
 * - Handles 404/500 pages with proper status codes
 * - Supports HTTPS/SSL
 * - ETag caching and range request support
 * - Framework-agnostic (works with Node.js, Bun, etc.)
 *
 * @example Basic usage
 * ```ts
 * const server = new StaticWebServer({
 *   buildDir: './build/client',
 *   pageMapPath: 'page-map.json', // Relative to buildDir
 * });
 *
 * await server.listen(3000);
 * ```
 *
 * @example With HTTPS
 * ```ts
 * const server = new StaticWebServer({
 *   buildDir: './build/client',
 *   pageMapPath: 'page-map.json',
 *   https: {
 *     key: privateKey,     // string | Buffer
 *     cert: certificate,   // string | Buffer
 *   },
 * });
 *
 * await server.listen(443);
 * ```
 */
export class StaticWebServer {
  private server: APIServer | null = null;
  private cache: StaticContentCache | null = null;
  private notFoundHTML: string | undefined = undefined;
  private errorHTML: string | undefined = undefined;
  private options: StaticWebServerOptions;

  constructor(options: StaticWebServerOptions) {
    // Validate required options
    if (!options.pageMapPath || typeof options.pageMapPath !== 'string') {
      throw new TypeError(
        'StaticWebServerOptions.pageMapPath is required and must be a string',
      );
    }

    if (!options.buildDir || typeof options.buildDir !== 'string') {
      throw new TypeError(
        'StaticWebServerOptions.buildDir is required and must be a string',
      );
    }

    // Validate optional string paths if provided
    if (options.notFoundPage && typeof options.notFoundPage !== 'string') {
      throw new TypeError(
        'StaticWebServerOptions.notFoundPage must be a string',
      );
    }

    if (options.errorPage && typeof options.errorPage !== 'string') {
      throw new TypeError('StaticWebServerOptions.errorPage must be a string');
    }

    // Validate singleAssets if provided
    if (options.singleAssets) {
      if (
        typeof options.singleAssets !== 'object' ||
        Array.isArray(options.singleAssets)
      ) {
        throw new TypeError(
          'StaticWebServerOptions.singleAssets must be a Record<string, string>',
        );
      }

      for (const [urlPath, filePath] of Object.entries(options.singleAssets)) {
        if (typeof urlPath !== 'string' || typeof filePath !== 'string') {
          throw new TypeError(
            'StaticWebServerOptions.singleAssets keys and values must be strings',
          );
        }
      }
    }

    // Validate assetFolders if provided
    if (options.assetFolders) {
      if (
        typeof options.assetFolders !== 'object' ||
        Array.isArray(options.assetFolders)
      ) {
        throw new TypeError(
          'StaticWebServerOptions.assetFolders must be a Record<string, string>',
        );
      }

      for (const [urlPrefix, fsPath] of Object.entries(options.assetFolders)) {
        if (typeof urlPrefix !== 'string' || typeof fsPath !== 'string') {
          throw new TypeError(
            'StaticWebServerOptions.assetFolders keys and values must be strings',
          );
        }
      }
    }

    this.options = options;
    // Server initialization is deferred to listen() for async setup
    // (reading page map, error pages, etc.)
  }

  /**
   * Start the static web server
   *
   * @param port Port number to listen on (default: 3000)
   * @param host Host to bind to (default: 'localhost')
   * @returns Promise that resolves when server is ready
   */
  public async listen(
    port: number = 3000,
    host: string = 'localhost',
  ): Promise<void> {
    // If server already exists, delegate to APIServer's own _isListening guard
    // (matches RedirectServer pattern — single source of truth for the error)
    if (this.server) {
      await this.server.listen(port, host);
      return;
    }

    // 1. Load page map and error pages
    const { singleAssetMap, notFoundHTML, errorHTML } = await this.buildMaps();

    // 2. Set error page state (used by handlers below via `this`)
    this.notFoundHTML = notFoundHTML;
    this.errorHTML = errorHTML;

    // 3. Build folderMap for additional asset directories
    const folderMap: Record<
      string,
      string | { path: string; detectImmutableAssets: boolean }
    > = {};

    // Paths are resolved relative to buildDir for consistency
    if (this.options.assetFolders) {
      for (const [urlPrefix, fsPath] of Object.entries(
        this.options.assetFolders,
      )) {
        folderMap[urlPrefix] = {
          path: path.resolve(this.options.buildDir, fsPath),
          detectImmutableAssets: this.options.detectImmutableAssets ?? true,
        };
      }
    }

    // 4. Create StaticContentCache externally so we can call updateConfig() on reload
    this.cache = new StaticContentCache({
      singleAssetMap,
      folderMap,
      cacheControl:
        this.options.cacheControl || 'public, max-age=0, must-revalidate',
      immutableCacheControl:
        this.options.immutableCacheControl ||
        'public, max-age=31536000, immutable',
    });

    // 5. Create plugins array (pass cache instance rather than raw config)
    const plugins: ServerPlugin[] = [
      staticContent(this.cache, 'static-web-server'),
      ...(this.options.plugins || []),
    ];

    // 6. Create APIServer with web-only configuration
    this.server = new APIServer({
      isDevelopment: this.options.isDevelopment ?? false,
      logErrors: this.options.logErrors, // Pass through error logging config
      plugins,
      https: this.options.https, // Pass through HTTPS options (includes SNI support)
      fastifyOptions: this.options.fastifyOptions,
      logging: this.options.logging,
      // Disable API handling entirely (pure web server mode)
      apiEndpoints: {
        apiEndpointPrefix: false,
      },
      // Split error handlers for web routes only
      // API handlers are omitted since apiEndpointPrefix is false (API handling disabled)
      // If API requests somehow occur, they fall back to default handlers
      // Arrow functions capture `this` so they always read the current notFoundHTML / errorHTML
      notFoundHandler: {
        web: (_request: FastifyRequest) => ({
          contentType: 'html' as const,
          content: this.notFoundHTML || DEFAULT_404_HTML,
          statusCode: 404,
        }),
      },
      errorHandler: {
        web: (
          _request: FastifyRequest,
          error: Error,
          isDevelopment: boolean,
        ) => ({
          contentType: 'html' as const,
          content: this.errorHTML || createDefault500HTML(isDevelopment, error),
          statusCode: 500,
        }),
      },
    });

    // 7. Start listening
    await this.server.listen(port, host);
  }

  /**
   * Reload the server configuration from disk without restarting.
   *
   * Re-reads the page-map.json and error pages from disk, then updates
   * the static content cache in-place. In-flight requests continue to be
   * served, new requests immediately see the updated file mappings.
   *
   * If the reload fails (e.g., the page-map.json is missing or invalid),
   * the server continues serving the previous configuration unchanged.
   *
   * _When_ to call reload is the caller's responsibility. A common pattern
   * is to invoke it after an SSG build completes:
   * ```ts
   * // After your build tool writes a new page-map.json:
   * await server.reload();
   * ```
   *
   * @throws {Error} If the server is not running
   * @throws {Error} If the page-map.json cannot be read or is invalid
   * @returns Promise that resolves when the reload is complete
   */
  public async reload(): Promise<void> {
    if (!this.server || !this.cache) {
      throw new Error('Server is not running. Call listen() first.');
    }

    // Load fresh page map + error pages from disk.
    // If this throws, the old state is fully preserved (no partial update).
    const { singleAssetMap, notFoundHTML, errorHTML } = await this.buildMaps();

    // Re-check after await in case stop() was called concurrently
    if (!this.cache) {
      return; // Server was stopped during reload, nothing to update
    }

    // Replace the page map and flush all file caches in one shot.
    // A build can change file contents in-place (same filename, new content),
    // and the rebuilt HTML pages reference JS/CSS bundles in the asset folders
    // that were likely rebuilt in the same step — so all caches need flushing,
    // not just the routes that changed. folderMap routing is not reloaded. It
    // derives from static options.assetFolders which doesn't change between builds.
    this.cache.replaceConfig({ singleAssetMap });

    // Update error page HTML (handlers read these via `this` on each request)
    this.notFoundHTML = notFoundHTML;
    this.errorHTML = errorHTML;
  }

  /**
   * Stop the server
   *
   * @returns Promise that resolves when server is stopped
   */
  public async stop(): Promise<void> {
    if (this.server) {
      await this.server.stop();
      this.server = null;
      this.cache = null;
      this.notFoundHTML = undefined;
      this.errorHTML = undefined;
    }
  }

  /**
   * Check if server is currently listening
   *
   * @returns True if server is listening, false otherwise
   */
  public isListening(): boolean {
    return this.server?.isListening() ?? false;
  }

  /**
   * Loads the page-map.json and error pages from disk, returning the built
   * singleAssetMap (with error page routes removed) and the error page HTML.
   *
   * Shared by listen() and reload() to avoid duplicating the loading logic.
   */
  private async buildMaps(): Promise<{
    singleAssetMap: Record<string, string>;
    notFoundHTML: string | undefined;
    errorHTML: string | undefined;
  }> {
    // 1. Load page-map.json (resolve relative to buildDir)
    const pageMapPath = path.resolve(
      this.options.buildDir,
      this.options.pageMapPath,
    );
    const pageMapResult = await readJSONFile(pageMapPath);

    if (pageMapResult.error || !pageMapResult.exists) {
      throw new Error(
        `Failed to load page map from ${pageMapPath}: ${pageMapResult.error || 'File not found'}`,
      );
    }

    const pageMap = pageMapResult.data;

    // Validate page map format
    if (
      typeof pageMap !== 'object' ||
      pageMap === null ||
      Array.isArray(pageMap)
    ) {
      throw new TypeError(
        `Invalid page map format: expected an object, got ${Array.isArray(pageMap) ? 'array' : typeof pageMap}`,
      );
    }

    // Validate page map entries (URL path → filename)
    for (const [urlPath, filename] of Object.entries(pageMap)) {
      if (typeof urlPath !== 'string' || typeof filename !== 'string') {
        throw new TypeError(
          `Invalid page map entry: keys and values must be strings (got ${typeof urlPath} → ${typeof filename})`,
        );
      }
    }

    // 2. Build singleAssetMap (URL → absolute file path)
    const singleAssetMap: Record<string, string> = {};

    // Add page-map assets
    for (const [urlPath, filename] of Object.entries(
      pageMap as Record<string, string>,
    )) {
      singleAssetMap[urlPath] = path.resolve(this.options.buildDir, filename);
    }

    // Merge in user-provided singleAssets (can override page-map assets)
    // Paths are resolved relative to buildDir for consistency
    if (this.options.singleAssets) {
      for (const [urlPath, filePath] of Object.entries(
        this.options.singleAssets,
      )) {
        singleAssetMap[urlPath] = path.resolve(this.options.buildDir, filePath);
      }
    }

    // 3. Load custom error pages if specified
    // Check page map first (if generated as SSG pages), then fall back to disk
    const notFoundResult = await loadErrorPageHTML(
      this.options.notFoundPage,
      singleAssetMap['/404'], // Check if user generated /404 page
      '404.html',
      this.options.buildDir,
    );

    const errorResult = await loadErrorPageHTML(
      this.options.errorPage,
      singleAssetMap['/500'], // Check if user generated /500 page
      '500.html',
      this.options.buildDir,
    );

    // 4. Remove error page routes from singleAssetMap to prevent serving them as normal routes
    // Error pages should only be accessible via error handlers (with proper 404/500 status codes)
    // If user generated error pages at ANY URL, they shouldn't be served with 200 status
    if (notFoundResult || errorResult) {
      // Remove ALL URLs that point to error page files (single loop for efficiency)
      for (const [url, filePath] of Object.entries(singleAssetMap)) {
        if (
          (notFoundResult && filePath === notFoundResult.filePath) ||
          (errorResult && filePath === errorResult.filePath)
        ) {
          delete singleAssetMap[url];
        }
      }
    }

    return {
      singleAssetMap,
      notFoundHTML: notFoundResult?.html,
      errorHTML: errorResult?.html,
    };
  }
}
